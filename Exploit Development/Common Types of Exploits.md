# Common Types of Exploits

## Buffer Overflow
A buffer overflow occurs when a program attempts to write more data to a buffer than it can hold, causing the excess data to overflow into adjacent memory locations. Attackers can exploit this vulnerability by providing input that overwrites critical data, such as the program's return address on the stack, and causes the program to execute malicious code.

```cpp
#include <iostream>
#include <cstring>
using namespace std;

void vulnerableFunction(char* input)
{
    char buffer[10];
    strcpy(buffer, input);
}

int main()
{
    char userInput[20];
    cin >> userInput;
    vulnerableFunction(userInput);
    return 0;
}
```

## Format String
A format string vulnerability occurs when a program uses user-supplied input as the format string for a printf-like function without proper input validation. Attackers can exploit this vulnerability to read or write arbitrary memory locations or execute arbitrary code.

```cpp
#include <cstdio>

void vulnerableFunction(const char *input)
{
    printf(input);
}

int main()
{
    char userInput[20];
    scanf("%s", userInput);
    vulnerableFunction(userInput);
    return 0;
}
```

## Integer Overflow/Underflow
An integer overflow/underflow occurs when a calculation results in a value that is too large or too small to be represented in the specified data type. Attackers can exploit this vulnerability by manipulating the input values to cause unexpected behavior or trigger a buffer overflow.

```cpp
#include <iostream>
using namespace std;

int vulnerableFunction(int x, int y)
{
    if (x > 0 && y > 0 && x + y < 0) {
        // This will only happen if an integer overflow occurs
        cout << "Integer overflow!" << endl;
    }
    return x + y;
}

int main()
{
    int a = 2147483645;
    int b = 3;
    vulnerableFunction(a, b);
    return 0;
}
```

## Use After Free
A use-after-free vulnerability occurs when a program attempts to access memory that has already been freed, which can result in a crash or arbitrary code execution. Attackers can exploit this vulnerability by manipulating the memory allocation and deallocation process to cause the program to use the freed memory.

```cpp
#include <cstdlib>
#include <iostream>
using namespace std;

int* vulnerableFunction(int* arr, int size)
{
    int* ptr = (int*)malloc(size * sizeof(int));
    ptr = arr;
    free(ptr); // free memory before function returns
    return ptr;
}

int main()
{
    int arr[3] = {1, 2, 3};
    int* result = vulnerableFunction(arr, 3);
    cout << result[0] << endl; // use after free vulnerability
    return 0;
}
```

## Stack/Heap-based Overflows
Stack and heap-based overflows are similar to buffer overflows, but they occur in the stack or heap memory regions rather than a fixed buffer. Attackers can exploit these vulnerabilities to execute malicious code by overwriting the function return address or function pointers.

```cpp
#include <iostream>
#include <cstdlib>
using namespace std;

void vulnerableFunction()
{
    char* buffer = (char*)malloc(10);
    char* ptr = buffer;
    for (int i = 0; i <= 20; i++) {
        *ptr = 'A'; // heap-based overflow
        ptr++;
    }
    free(buffer);
}

int main()
{
    vulnerableFunction();
    return 0;
}
```

## Null Pointer Dereference
A null pointer dereference occurs when a program attempts to access memory through a null pointer, which can result in a crash or arbitrary code execution. Attackers can exploit this vulnerability by manipulating the program's input to cause the null pointer to be dereferenced.

```cpp
#include <iostream>
using namespace std;

void vulnerableFunction(int* ptr)
{
    cout << *ptr << endl;
}

int main()
{
    int* ptr = nullptr; // null pointer
    vulnerableFunction(ptr);
    return 0;
}
```

## DLL Injection
DLL injection is a technique used to execute malicious code by forcing a program to load a dynamic-link library (DLL) that contains the attacker's code. Attackers can exploit this vulnerability by tricking the program into loading a malicious DLL or by exploiting a vulnerability in a legitimate DLL.
(we will focus on DLL injection a bit more in a future chapter)

```cpp
#include <windows.h>
#include <iostream>
using namespace std;

int main()
{
    // Load malicious DLL into process
    HMODULE hMod = LoadLibrary(TEXT("malicious.dll"));
    if (hMod == NULL) {
        cout << "Failed to load DLL" << endl;
        return 1;
    }
    return 0;
}
```

## Integer/Buffer Overflows in Web Applications
Integer and buffer overflows can also occur in web applications when input is not properly validated or sanitized. Attackers can exploit these vulnerabilities by injecting malicious input that overflows a buffer or integer value, potentially leading to arbitrary code execution.

```cpp
#include <string>
#include <iostream>
using namespace std;

int main()
{
    string userInput = "username=admin&password=pass1234&access_level=0";
    if (userInput.find("access_level=1") != string::npos) {
        cout << "Access granted!" << endl;
    } else {
        cout << "Access denied." << endl; // Integer overflow vulnerability
    }
    string buffer(10, 'A');
    userInput = "username=admin&password=" + buffer;
    cout << "POST data: " << userInput << endl; // Buffer overflow vulnerability
    return 0;
}
```

## Links
### Continue to Next Section
- [Exploit Development Process](Exploit%20Development%20Process.md)
### Back to this topics Table of Contents
- [Table of Contents](Table%20of%20Contents.md)
### Back to the Reverse Engineering Guide's Table of Contents
- [Reverse Engineering](../README.md)

